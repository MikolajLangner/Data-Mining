---
title: "Raport 2"
subtitle: "Eksploracja danych"
author:   |
          |    Mikołaj Langner, Marcin Kostrzewa
          |    nr albumów: 255716, 255749
date: "2021-04-19"
output: 
  pdf_document:
    toc: true
    fig_caption: yes
    fig_width: 5 
    fig_height: 4 
    number_sections: true
    includes:
      in_header: "preambula.tex" 
fontsize: 12pt 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=6, fig.height=4)
library(datasets)
library(dplyr)
library(DataExplorer)
library(ggplot2)
library(ggbeeswarm)
library(ggfortify)
library(ggbiplot)
library(ggcorrplot)
library(wesanderson)
library(cowplot)
library(EnvStats)
library(arules)
library(e1071)
library(kableExtra)
library(reshape2)
```

# Wstęp
<!--  można napisać trochę więcej -->

Sprawozdanie zawiera rozwiązanie zadań z listy 2. Dotyczą one zagadnień dyskretyzacji i redukcji wymiaru.

# Zadanie 1

W pierwszym zadaniu mamy dokonać dyskretyzacji cech ciągłych ze zbioru `iris` i ocenić jej jakość.

## Wczytanie danych i wstępna analiza
```{r}
data(iris)
```

Wybierzmy zmienne o najlepszej i najgorszej zdolności dyskryminacyjnej. W tym celu narysujemy wykresy pudełkowe oraz wyliczymy współczynniki zmienności każdej ze zmiennych z podziałem na poszczególne gatunki irysów i porównamy ich rozkłady.

```{r include=FALSE}
str(iris)
plot_intro(iris)
```

```{r}
plot_boxplot(iris, by="Species")
aggregate(. ~ Species, iris, cv)
```

Możemy zauważyć, że zmienna Petal.Length najefektywniej rozdziela poszczególne gatunki, natomiast zmienna Sepal.Width radzi sobie z tym najgorzej.

## Metody dyskretyzacji
Porównamy ze sobą cztery metody dyskretyzacji nienadzorowanej:

 - equal width,
 - equal frequency,
 - k-means clustering,
 - dyskretyzację dla przedziałów zadanych przez użytkownika.

### Najlepiej separująca zmienna
Zacznijmy od zmiennej Petal.Length, która najlepiej rozdziela poszczególne gatunki irysów.
```{r message=FALSE, fig.height=3, fig.width=3.25, echo=FALSE}
intervals <- c(min(iris$Petal.Length), 2, 5, max(iris$Petal.Length))
for (method in c("interval", "frequency", "cluster", "fixed")) {
  petal.length.discretized <- if (method != "fixed") 
    discretize(iris$Petal.Length, method=method) else 
    discretize(iris$Petal.Length, method=method, breaks=intervals)
  print(ggplot(iris, aes(Petal.Length)) +
          geom_histogram() +
          geom_vline(xintercept=attributes(petal.length.discretized)$"discretized:breaks") +
          ggtitle(method))
  print(ggplot(iris, aes(Species, Petal.Length)) +
    geom_quasirandom(aes(col=Species)) +
    scale_color_manual(values=wes_palette("GrandBudapest1", 3)) +
    geom_hline(yintercept=attributes(petal.length.discretized)$"discretized:breaks") +
    theme(legend.position = "none"))
  discretized.table <- table(petal.length.discretized, iris$Species)
  matchClasses(discretized.table)
}
```

### Najgorzej separująca zmienna
Możemy zobaczyć teraz jak poszczególne metody działają dla zmiennej Sepal.Width, która najgorzej radzi sobie z rozdzielaniem gatunków.
```{r message=FALSE, fig.height=3, fig.width=3.25, echo=FALSE}
intervals <- c(min(iris$Sepal.Width), 2.5, 3, max(iris$Sepal.Width))
for (method in c("interval", "frequency", "cluster", "fixed")) {
  sepal.width.discretized <- if (method != "fixed") 
    discretize(iris$Sepal.Width, method=method) else 
    discretize(iris$Sepal.Width, method=method, breaks=intervals)
  print(ggplot(iris, aes(Sepal.Width)) +
          geom_histogram() +
          geom_vline(xintercept=attributes(sepal.width.discretized)$"discretized:breaks") +
          ggtitle(method))
  print(ggplot(iris, aes(Species, Sepal.Width)) +
    geom_quasirandom(aes(col=Species)) +
    scale_color_manual(values=wes_palette("GrandBudapest1", 3)) +
    geom_hline(yintercept=attributes(sepal.width.discretized)$"discretized:breaks") +
    theme(legend.position = "none"))
  discretized.table <- table(sepal.width.discretized, iris$Species)
  matchClasses(discretized.table)
}
```

Dla obu zmiennych każda z metod wypada równie dobrze, przy czym, najlepsze wyniki produkują metody równej częstości oraz k-średnich.

## Metody dyskretyzacji z wartościami odstającymi
Rozpatrzmy teraz dyskretyzację przy dodaniu sztucznie wartości odstających.
### Zmienna Petal.Length
Zacznijmy znowu od zmiennej Petal.Length.
```{r message=FALSE, fig.height=3, fig.width=3.25, echo=FALSE}
iris$Petal.Length[which.min(iris$Petal.Length)] <- min(iris$Petal.Length) - IQR(iris$Petal.Length)
iris$Petal.Length[which.max(iris$Petal.Length)] <- max(iris$Petal.Length) + IQR(iris$Petal.Length)
intervals <- c(min(iris$Petal.Length), 2, 5, max(iris$Petal.Length))
for (method in c("interval", "frequency", "cluster", "fixed")) {
  petal.length.discretized <- if (method != "fixed") 
    discretize(iris$Petal.Length, method=method) else 
    discretize(iris$Petal.Length, method=method, breaks=intervals)
  print(ggplot(iris, aes(Petal.Length)) +
          geom_histogram() +
          geom_vline(xintercept=attributes(petal.length.discretized)$"discretized:breaks") +
          ggtitle(method))
  print(ggplot(iris, aes(Species, Petal.Length)) +
    geom_quasirandom(aes(col=Species)) +
    scale_color_manual(values=wes_palette("GrandBudapest1", 3)) +
    geom_hline(yintercept=attributes(petal.length.discretized)$"discretized:breaks") +
    theme(legend.position = "none"))
  discretized.table <- table(petal.length.discretized, iris$Species)
  matchClasses(discretized.table)
}
```

### Zmienna Sepal.Width
Dla zmiennej Sepal.Width po dodaniu wartości odstających dyskretyzacja wygląda następująco:
```{r message=FALSE, fig.height=3, fig.width=3.25, echo=FALSE}
iris$Sepal.Width[which.min(iris$Sepal.Width)] <- min(iris$Sepal.Width) - IQR(iris$Sepal.Width)
iris$Sepal.Width[which.max(iris$Sepal.Width)] <- max(iris$Sepal.Width) + IQR(iris$Sepal.Width)
intervals <- c(min(iris$Sepal.Width), 2.5, 3, max(iris$Sepal.Width))
for (method in c("interval", "frequency", "cluster", "fixed")) {
  sepal.width.discretized <- if (method != "fixed") 
    discretize(iris$Sepal.Width, method=method) else 
    discretize(iris$Sepal.Width, method=method, breaks=intervals)
  print(ggplot(iris, aes(Sepal.Width)) +
          geom_histogram() +
          geom_vline(xintercept=attributes(sepal.width.discretized)$"discretized:breaks") +
          ggtitle(method))
  print(ggplot(iris, aes(Species, Sepal.Width)) +
    geom_quasirandom(aes(col=Species)) +
    scale_color_manual(values=wes_palette("GrandBudapest1", 3)) +
    geom_hline(yintercept=attributes(sepal.width.discretized)$"discretized:breaks") +
    theme(legend.position = "none"))
  discretized.table <- table(sepal.width.discretized, iris$Species)
  matchClasses(discretized.table)
}
```
Nie powinien dziwić fakt, że największa zmiana w poprawności predykcji dotknęła metodę przedziałów równej długości, gdyż pojedyncza obserwacja całkowicie zmienia dobór miejsc partycji przedziału.

# Zadanie 2

## Wczytanie i przygotowanie danych

Teraz naszym zadaniem jest dokonanie analizy składów głównych (PCA) dla zbioru `state.x77`, który zbiera &hellip;

Wczytajmy dane i uzupełnijmy je o informacje geograficzne o wszytkich stanach.

```{r}
data(state)
state <- as.data.frame(state.x77)
state$region <- state.region
state$division <- state.division
state.subset <- subset(state, select=-c(region, division))
```

By rozstrzygnąć, czy potrzebna jest normalizacja danych, przeanalizujemy wykresy pudełkowe oraz wyznaczymy odchylenia standardowe i współczynniki zmienności.

```{r data boxplot, message=FALSE, echo=FALSE, fig.height=2.8}
ggplot(data=melt(state.subset), aes(x=variable, y=value)) + geom_boxplot(aes(fill=variable))
```

```{r tabela_1, echo=FALSE, eval=TRUE, results='asis'}
var <- sapply(state.subset, function(X) c(sd(X), cv(X)))
summary.matrix <- as.matrix(var)
row.names(summary.matrix) <- c("Odchylenie standardowe", "Wspolczynnik zmiennosci")
summary.matrix %>% kbl(caption="Odchylenie standardowe i wspolczynnik zmiennosci dla zmienych", format="latex", digits=3) %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
```

Widać, że zmienne wymagają standaryzacji --- ich wariancję zbyt mocno się różnią.

## Składowe główne i ich analiza

Wyznaczymy teraz składowe główne i przedstawimy ich rozrzut, wykorzystując wykresy pudełkowe.

```{r pca}
after.pca <- prcomp(state.subset, retx=T, center=T, scale.=T)
```

```{r pca boxplot, echo=FALSE, message=FALSE, fig.height=2.9}
ggplot(data = melt(data.frame(after.pca$x)), 
       aes(x=variable, y=value)) + geom_boxplot(aes(fill=variable))
```

Przypatrzmy się teraz wektorom ładunków dla trzech pierwszych składowych głównych.

```{r loadings table, echo=FALSE}
matrix = as.matrix(after.pca$rotation[, c(1:3)])
matrix %>% kbl(caption="Odchylenie standardowe i wspolczynnik zmiennosci dla zmienych", format="latex", digits=3) %>% kable_styling(latex_options=c('hold_position'))
```

```{r loading plots}
# tutaj wektor ładunków - barplot
```

Wnioski --- jeszcze się napisze &hellip;

Zbadajmy teraz jaka część wyjaśnionej wariancji odpowiada kolejnym składowym głównym.

```{r variance, echo=FALSE, fig.width=8}
variance_proportion <- (after.pca$sdev ^2) / sum(after.pca$sdev^2)

df <- data.frame(variance_proportion)

df["cumulative.variance"] <- cumsum(variance_proportion)

labels <- paste0("PC", 1:8)
df["PC"] = labels

barplot1 <- ggplot(data=df,
                   aes(x=PC, y=variance_proportion, fill=PC)) + 
                   geom_bar(stat="identity")
barplot2 <- ggplot(data=df, aes(x=PC, y=cumulative.variance, fill=PC)) + 
                    geom_bar(stat="identity") 
plot_grid(barplot1, barplot2, ncol=2, nrow=1)
```

```{r table, echo=FALSE}
variance.matrix <- t(df[1:5, 1:2])
colnames(variance.matrix) <- paste0("PC", 1:5)
rownames(variance.matrix) <- c("Proporcja wariancji", "Skumulowana wariancja")
variance.matrix %>% kbl(caption="Odchylenie standardowe i wspolczynnik zmiennosci dla zmienych", format="latex", digits=3) %>% kable_styling(latex_options=c('hold_position'))
```

Wnioski --- jeszcze się napisze &hellip;

## Wizualizacja danych

W tej części wygenerujemy wykresy rozrzutu 2d dla dwóch pierwszych składowych głównych.
```{r 2d plot region, echo=FALSE}
ggplot(dat = data.frame(after.pca$x), aes(x=PC1, y=PC2)) + geom_point(aes(color = state$region))
```
```{r 2d plot division, echo=FALSE}
ggplot(dat = data.frame(after.pca$x), aes(x=PC1, y=PC2)) + geom_point(aes(color = state$division))
```

Przygotowaliśmy także wykresy 3d --- kod umieściliśmy w dodatkowych skrypcie.

## Korelacja zmiennych
Wygenerujmy teraz dwuwykres.

```{r biplot, echo=FALSE}
ggbiplot(after.pca, obs.scale = 2, var.scale = 2, varname.size = 3.7, ellipse = TRUE, 
         groups = state$region)
```

```{r correlation matrix, echo=FALSE}
cor.matrix <- cor(state.subset)
cor.matrix %>% kbl(caption="Odchylenie standardowe i wspolczynnik zmiennosci dla zmienych", format="latex", digits=3) %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
```

## Wnioski do zadania 2
# Zadanie 3