\documentclass{article}

\usepackage[OT4]{polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{wrapfig}


<<Globals, echo=FALSE, warning=FALSE>>=
library(knitr)
library(kableExtra)
opts_chunk$set(fig.path='figure/', fig.align='center', fig.pos='h', fig.width=6, fig.height=5)
@

\title{Lista 1}
\author{Mikołaj Langner, Marcin Kostrzewa}
\date{31.3.2021}

\begin{document}

\maketitle

\section{Wstęp}
W niniejszym sprawozdaniu zajmować się będziemy danymi dotyczącymi klientów pewnej sieci telefonii komórkowej.
Naszym zadaniem będzie odkrycie zależności między zmiennymi, które określą przyczyny rezygnacji klientów z oferty (churn analysis).

\section{Wczytanie i identyfikacja danych}
Wczytajmy dane z pliku i przeprowadźmy ich wstępną analizę i obróbkę:

<<Load and view data>>=
df <- read.csv('churn.txt', stringsAsFactors = TRUE)
df$Area.Code = as.factor(df$Area.Code)
@ 

\begin{itemize}

\item poznajmy rozmiar naszych danych:
<<rozmiar danych>>=
dim(df)
@
--- jest 21 zmiennych i 3333 obserwacji;

\item sprawdźmy ich typy:
<<tabela_1, echo=FALSE, eval=TRUE, results='asis'>>=
table1 <- data.frame(sapply(df[, 1:11], class))
colnames(table1) <- c("Typ zmiennej")
t(table1) %>% kbl(caption="Typy zmiennych", format="latex") %>% kable_styling(latex_options=c('hold_position', 'scale_down'))

table2 <- data.frame(sapply(df[, -1:-11], class))
colnames(table2) <- c("Typ zmiennej")
t(table2) %>% kable(format="latex") %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
@

\item sprawdźmy czy pojawiają się wartości brakujące:
<<brakujące dane>>=
sum(is.na(df))
@
--- nie ma więc brakujących obserwacji;
\item usuńmy dane pełniące rolę indentyfikatora (numer telefonu):
<<Delete `Phone` column>>=
df <- subset(df, select=-Phone)
@

\end{itemize}

\section{Analiza zmiennych, szkanie zależności}

\subsection{Wskaźniki sumaryczne}


<<Import libraries, warning=FALSE, message=FALSE>>=
# wczytanie potrzebnych bibliotek
library(ggplot2)
library(ggmosaic)
library(GGally)
library(tidyr)
library(dplyr)
library(EnvStats)
library(DescTools)
library(moments)
@

Teraz podzielimy zmienne ze względu na ich typ (jakościowe --- \verb|factors|, ilościowe --- \verb|numerics|) oraz wykonamy kilka wykresów, które pomogą w zauważeniu pewnych zależności i wyborze najistotniejszych pod względem naszej analizy atrybutów.
<<Split data by numerics and factors>>=
factors <- subset(df, select=sapply(df, is.factor))
numerics <- subset(df, select=sapply(df, function(x) !is.factor(x)))
@

Sprawdźmy zależności pomiędzy zmiennymi ciągłymi.
<<Pair plot for continuous variables, warning=FALSE, message=FALSE>>=
continuous <- subset(numerics, select=sapply(numerics, function(x) !is.integer(x)))
ggpairs(continuous,
        lower=list(continuous=wrap("points", alpha=.4, size=.01)))
@
Możemy zauważyć, że zmienne z przyrostkami `.Mins` oraz `.Charge` są ze sobą idealnie skorelowane. Odrzućmy zatem od razu dane z przyrostkiem `.Charge` dla ułatwienia dalszej analizy. Nie ma natomiast korelacji pomiędzy pozostałymi atrybutami.

<<Drop .Charhe variables>>=
numerics <- subset(numerics, select=-c(Day.Charge, Eve.Charge, Night.Charge, Intl.Charge))
@

Wykonamy teraz wykresy zmiennych ilościowych, dzieląc klientów na dwie grupy:
\begin{itemize}
  \item tych, którzy zrezygnowali --- \verb|Churn. == TRUE |,
  \item tych, którzy pozostali lojalni --- \verb|Churn. == FALSE|.
\end{itemize}
<<Add grouping category to numerics>>=
numerics <- data.frame(numerics, Churn. = df$Churn.)
@

Poniżej wykresy słupkowe dla danych jakościowych.
<<Bar plots, warning=FALSE, message=FALSE, fig.width=5.5, fig.height=4>>=
ggplot(gather(factors, "key", "value", -Churn.), aes(value, fill=Churn.)) +
  geom_bar(position="fill") +
  facet_wrap(~key, scales='free')
@

Możemy zauważyć, że osoby, które posiadały plan międzynarodowy, jak i te, które nie posiadały planu skrzyki głosowej częściej rezygnowały z usług. Zmienne \verb|Area.Code| i \verb|State| nie pokazują żadnych istotnych różnic pomiędzy tymi dwoma grupami.


Poniżej znajdują się wykresy empirycznych gęstości.
<<Densities, warning=FALSE, message=FALSE>>=
ggplot(gather(numerics, "key", "value", -Churn.), aes(x=value, color=Churn.)) +
  geom_freqpoly(aes(y=..density..), position="identity") +
  facet_wrap(~key, scales='free')
@
Widoczne gołym okiem różnice są zauważalne w przypadku zmiennych: \verb|Day.Mins|, \verb|Customer.Service.Calls|, \verb|Eve.Calls|.

Poniżej generujemy wykresy pudełkowe. 
<<Boxplot, warning=FALSE, message=FALSE>>=
ggplot(gather(numerics, "key", "value", -Churn.), aes(value, color=Churn.)) +
  geom_boxplot(aes(x=value)) +
  facet_wrap(~key, scales='free')
@
Ponownie, duże różnice uwidaczniają się dla zmiennych: \verb|Day.Mins|, \verb|Customer.Service.Calls|, \verb|Eve.Calls|.

Stworzymy również wykresy empirycznych dystrybuant.
<<Ecdf, warning=FALSE, message=FALSE>>=
ggplot(gather(numerics, "key", "value", -Churn.), aes(value, color=Churn.)) +
  stat_ecdf() +
  facet_wrap(~key, scales='free')
@
Coś tam, coś tam \ldots

By wykryć, dla których zmiennych następuja najważniejsza różnica pomiędzy klientami lojalnymi, a tymi którzy zrezygnowali z usług, posłużymy się również testem Kołmogorova-Smirnova. Poniżej znajduje się funkcja, która wyznacza wyniki tego testu dla naszych zmiennych. 
<<kstest, warning=FALSE>>=
churn.kstest <- function(feature) {
  yes <- subset(numerics, subset=Churn.=="True.")
  no <- subset(numerics, subset=Churn.=="False.")
  return(c(ks.test(yes[[feature]], no[[feature]])[c("statistic", "p.value")]))
}
@

Tabela poniżej zbiera wyniki przeprowadzonych testów statystycznych.
<<tabela_3, echo=FALSE, eval=TRUE, results='asis', warning=FALSE>>=
data = data.frame(Zmienna=c("statistic", "pvalue"))
yes <- subset(numerics, subset=Churn.=="True.")
no <- subset(numerics, subset=Churn.=="False.")

for (i in colnames(subset(numerics, select=-Churn.))) {
  data[i] = as.numeric(churn.kstest(i))
}

data %>% kbl(caption="Wyniki testu Kolmogorova-Smirnova", format="latex") %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
@
Możemy zauważyć, że testy na największe różnice (duża wartość zmiennej \verb|statistic|, mała zmiennej \verb|pvalue|) wskazują w przypadku zmiennych: CustServ.Calls, Day.Mins, Eve.Mins, 


Po dogłębnym przeanalizowaniu wykresów i wyników testów Kołmogorova-Smirnova, zauważmy, że istotne dla naszej analizy to następujące zmienne:
\begin{itemize}
  \item ilościowych:
    \begin{itemize}
    \item CustServ.Calls,
    \item Day.Mins,
    \item Eve.Mins;
    \end{itemize}
  \item jakościowych
    \begin{itemize}
    \item Int.l.Plan,
    \item VMail.Plan,
    \item Churn.
    \end{itemize}
\end{itemize}

\section{Analiza wybranych zmiennych}
Skupmy się jedynie na wybranych zmiennych:
<<nowy podzbiór danych, warning=FALSE>>=
important <- subset(df, select=c(CustServ.Calls, Day.Mins, Eve.Mins, Int.l.Plan,
                                 VMail.Plan, VMail.Message, Churn.))
@

Wyznaczmy dla nich wskaźniki sumaryczne.

<<funkcja do wyznaczania statystyk opisowych>>=
my_summary <- function(x) {
  statistics <- c(mean(x), quantile(x, 0.25), median(x), quantile(x, 0.75), 
                  IQR(x), min(x), max(x), var(x), sd(x), sd(x) / mean(x), 
                  kurtosis(x), skewness(x))
  names(statistics) <- c("Srednia", "Q1", "Mediana", "Q3", "IQR", "Min", "Max", 
                         "Wariancja", "Odchylenie standardowe", "Wspolczynnik zmiennosci",
                         "Kurtoza", "Skosnosc")
  return(statistics)
}
@

<<tabela_2, echo=FALSE, eval=TRUE, results='asis'>>=
nazwy.wskaznikow <- names(my_summary(df$Day.Mins))
nazwy.zmiennych <- c("CustServ.Calls", "Day.Mins", "Eve.Mins", "VMail.Message")
CustServ.Calls.summary <- as.vector(my_summary(df$CustServ.Calls))
Day.Mins.summary <- as.vector(my_summary(df$Day.Mins))
Eve.Mins.summary <- as.vector(my_summary(df$Eve.Mins))
VMail.Message.summary <- as.vector(my_summary(df$VMail.Message))
summary.matrix <- rbind(CustServ.Calls.summary, Day.Mins.summary, Eve.Mins.summary, VMail.Message.summary)
row.names(summary.matrix) <- nazwy.zmiennych
colnames(summary.matrix) <- nazwy.wskaznikow
summary.matrix %>% kbl(caption="Wskazniki sumaryczne dla wybranych zmiennych", format="latex") %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
@


<<histograms, warning=FALSE, message=FALSE>>=
subset = subset(important, select=-c(Churn., Int.l.Plan, VMail.Plan))
ggplot(gather(subset, 'key', 'value'), aes(x=value)) +
  geom_histogram(aes(y=..density..), position="identity", color="orange") +
  facet_wrap(~key, scales='free')
@


\verb|Day.Mins| i \verb|Eve.Mins| mają rozkład symetryczny, natomiast pozostałe \verb|CustServ.Calls| i \verb|VMail.Message| mają rozkład prawostronnie skośny. Dodatkowo charakteryzują się one dużą zmiennością.

Teraz przyjrzyjmy się bliżej wybranym zmiennym jakościowym.

<<ilosciowe, eval=TRUE, echo=FALSE, warning=FALSE>>=
tab1 <- data.frame(table(df$Churn.))
tab2 <- data.frame(table(df$Int.l.Plan))
tab3 <- data.frame(table(df$VMail.Plan))
tab1 <- tab1 %>% rename(Churn=Var1, Count=Freq) 
tab2 <- tab2 %>% rename(Int.l.Plan=Var1, Count=Freq) 
tab3 <- tab3 %>% rename(VMail.Plan=Var1, Count=Freq) 
tab1 %>% kbl(format="latex") %>% kable_styling(latex_options=c('hold_position'))
tab2 %>% kbl(format="latex") %>% kable_styling(latex_options=c('hold_position'))
tab3 %>% kbl(format="latex") %>% kable_styling(latex_options=c('hold_position'))
@

<<slupkowe dla wybranych, echo=TRUE, warning=FALSE, fig.height=3.5, fig.width=6>>=
ggplot(gather(important, "key", "value", -c(CustServ.Calls, Day.Mins, Eve.Mins, VMail.Message)), aes(value)) +
  geom_bar(position="dodge", color='orange') +
  facet_wrap(~key, scales='free')
@
Łatwo stwierdzić, że większośc klientów była lojalna ( $\approx 86$\%), nie miała wykupionego planu międzynarodowego ($\approx 90$ \%) oraz nie miało dostępu do planu poczty głosowej ($\approx 72$\%).  

\subsection{Analiza wybranych zmiennych z podziałem na grupy}

Poniższe tabele zawierają informacje o wartościach wskaźników sumarycznych dla zmiennych ilosciowych, tym razem uwzględniają one podział klientów na grupy.
<<sumaryczne dla grup, echo=FALSE, eval=TRUE>>=
# for (i in list(list(important$Day.Mins, "Day.Mins"), 
#                list(important$Eve.Mins, "Eve.Mins"),
#                list(important$CustServ.Calls, "CustServ.Calls"), 
#                list(important$VMail.Message, "VMail.Message"))) {
#   w <- by(data=i[1], INDICES=important$Churn., my_summary)
#   tab <- rbind(w$False., w$True.)
#   row.names(tab) <- c("False.", "True.")
#   tab %>% kbl(format="latex", digits=2, caption=i[2]) %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
# }

w1 <- by(data=important$Day.Mins, INDICES=important$Churn., my_summary)
w2 <- by(data=important$Eve.Mins, INDICES=important$Churn., my_summary)
w3 <- by(data=important$CustServ.Calls, INDICES=important$Churn., my_summary)
w4 <- by(data=important$VMail.Message, INDICES=important$Churn., my_summary)

tabela1 <- rbind(w1$False., w1$True.) 
row.names(tabela1) <- c("False.", "True.")
tabela1 %>% kbl(format="latex", digits=2, caption="Day.Mins"  ) %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
 
tabela2 <- rbind(w2$False., w2$True.) 
row.names(tabela1) <- c("False.", "True.")
tabela2 %>% kbl(format="latex", digits=2, caption="Eve.Mins"  ) %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
 
tabela3 <- rbind(w3$False., w3$True.) 
row.names(tabela1) <- c("False.", "True.")
tabela3 %>% kbl(format = "latex", digits=2, caption="CustServ.Calls"  ) %>% kable_styling(latex_options=c('hold_position', 'scale_down'))

tabela4 <- rbind(w4$False., w4$True.) 
row.names(tabela1) <- c("False.", "True.")
tabela4 %>% kbl(format="latex", digits=2, caption="VMail.Message"  ) %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
@

<<histogramy dla grup, warning=FALSE, message=FALSE>>=
subset = subset(important, select=-c(Int.l.Plan, VMail.Plan))
ggplot(gather(subset, 'key', 'value', -Churn.), aes(x=value, color=Churn.)) +
  geom_histogram(aes(y=..density..), position="identity") +
  facet_wrap(~key, scales='free')
@

<<ilosciowe dla grup, echo=FALSE, eval=TRUE>>=
freq.table <- function(x) {
  return(table(x) / length(x))
}
w1 <- by(data=important$Churn., INDICES=important$Int.l.Plan, freq.table)
w2 <- by(data=important$Churn., INDICES=important$VMail.Plan, freq.table)

tab1 <- rbind(w1$no, w1$yes)
row.names(tab1) <- c("no", "yes")
tab2 <- rbind(w2$no, w2$yes)
row.names(tab2) <- c("no", "yes")
tab1 %>% kbl(caption="Int.l.Plan", format="latex", digits=2) %>% kable_styling(latex_options=c('hold_position'))
tab2 %>% kbl(caption="VMail.Plan", format="latex", digits=2) %>% kable_styling(latex_options=c('hold_position'))
@


<<scatterplot, echo=TRUE, message=FALSE, warning=FALSE>>=
subset = subset(important, select=-c(Int.l.Plan, VMail.Plan))
subset %>% ggpairs(.,
mapping = ggplot2::aes(color=Churn.),
columns=1:4, 
lower=list(continuous=wrap("points", alpha=.4, size=.01)),
upper=list(continuous="blank"),
diag=list(continuous="blank"))
@


\section{Podsumowanie}
Najważniesze wnioski z naszej analizy to:
\begin{itemize}
  \item jakiś wniosek
\end{itemize}

\end{document}