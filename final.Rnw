\documentclass{article}

\usepackage[OT4]{polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}

<<Globals, echo=FALSE, warning=FALSE>>=
library(knitr)
library(kableExtra)
opts_chunk$set(fig.path='figure/', fig.align='center', fig.pos='H',fig.width=5, fig.height=4)
@

\title{Lista 1}
\author{Mikołaj Langner, Marcin Kostrzewa}
\date{31.3.2021}

\begin{document}

\maketitle

\section{Wstęp}
W niniejszym sprawozdaniu zajmować się będziemy danymi dotyczącymi klientów pewnej sieci telefonii komórkowej.
Naszym zadaniem będzie odkrycie zależności między zmiennymi, które określą przyczyny rezygnacji klientów z oferty (churn analysis).

\section{Wczytanie i identyfikacja danych}
Wczytajmy dane z pliku i przeprowadźmy ich wstępną analizę i obróbkę:

<<Load and view data>>=
df <- read.csv('churn.txt', stringsAsFactors = TRUE)
df$Area.Code = as.factor(df$Area.Code)
@ 

\begin{itemize}

\item poznajmy rozmiar naszych danych:
<<rozmiar danych>>=
dim(df)
@
--- jest 21 zmiennych i 3333 obserwacji;

\item sprawdźmy ich typ:
<<tabela_1, echo=FALSE, eval=TRUE, results='asis'>>=
table1 <- data.frame(sapply(df, class))
colnames(table1) <- c("Typ zmiennej")
t(table1) %>% kbl(caption="Typy zmiennych", format="latex") %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
@
Zmienna `Churn.` mówi o tym, czy dany klient zrezygnował z oferty.

\item sprawdźmy czy pojawiają się wartości brakujące:
<<brakujące dane>>=
sum(sapply(df, function(x) sum(is.na(x))))
@
--- nie ma więc brakujących obserwacji;
\item usuńmy dane pełniące rolę indentyfikatora (numer telefonu):
<<Delete `Phone` column>>=
df <- subset(df, select=-Phone)
@

\end{itemize}

\section{Analiza zmiennych, szkanie zależności}
Teraz podzielimy zmienne ze względu na ich typ oraz wykonamy kilka wykresów, które pomogą w zauważeniu pewnych zależności i wyborze najistotniejszych pod względem naszej analizy atrybutów.
<<Import libraries, warning=FALSE, message=FALSE>>=
# wczytanie potrzebnych bibliotek
library(ggplot2)
library(ggmosaic)
library(GGally)
library(tidyr)
library(dplyr)
library(EnvStats)
library(DescTools)
library(moments)
@


<<Split data by numerics and factors>>=
factors <- subset(df, select=sapply(df, is.factor))
numerics <- subset(df, select=sapply(df, function(x) !is.factor(x)))
@

Sprawdźmy zależności pomiędzy zmiennymi ciągłymi.
<<Pair plot for continuous variables, warning=FALSE, message=FALSE>>=
continuous <- subset(numerics, select=sapply(numerics, function(x) !is.integer(x)))
ggpairs(continuous,
        lower=list(continuous=wrap("points", alpha=.4, size=.01)))
@
Możemy zauważyć, że zmienne z przyrostkami `.Mins` oraz `.Charge` są ze sobą idealnie skorelowane. Odrzućmy zatem od razu dane z przyrostkiem `.Charge` dla ułatwienia dalszej analizy.

<<Drop .Charhe variables>>=
numerics <- subset(numerics, select=-c(Day.Charge, Eve.Charge, Night.Charge, Intl.Charge))
@

<<Add grouping category to numerics>>=
numerics <- data.frame(numerics, Churn. = df$Churn.)
@

<<Overviews plots grouped, warning=FALSE, message=FALSE>>=
ggplot(gather(factors, "key", "value", -Churn.), aes(value, fill=Churn.)) +
  geom_bar(position="fill") +
  facet_wrap(~key, scales='free')

ggplot(gather(numerics, "key", "value", -Churn.), aes(x=value, color=Churn.)) +
  geom_freqpoly(aes(y=..density..), position="identity") +
  facet_wrap(~key, scales='free')

ggplot(gather(numerics, "key", "value", -Churn.), aes(value, color=Churn.)) +
  geom_boxplot(aes(x=value)) +
  facet_wrap(~key, scales='free')

ggplot(gather(numerics, "key", "value", -Churn.), aes(value, color=Churn.)) +
  stat_ecdf() +
  facet_wrap(~key, scales='free')
@

By wykryć, dla których zmiennych następuja najważniejsza różnica pomiędzy klientami lojalnymi, a tymi którzy zrezygnowali z usług, posłużymy się również testem Kołmogorova-Smirnova. Poniżej znajduje się funkcja, która wyznacza wyniki tego testu dla naszych zmiennych. 
<<kstest, warning=FALSE>>=
churn.kstest <- function(feature) {
  yes <- subset(numerics, subset=Churn.=="True.")
  no <- subset(numerics, subset=Churn.=="False.")
  return(c(ks.test(yes[[feature]], no[[feature]])[c("statistic", "p.value")]))
}
@

Tabela poniżej zbiera wyniki przeprowadzonych testów statystycznych.
<<tabela_3, echo=FALSE, eval=TRUE, results='asis', warning=FALSE>>=
data = data.frame(Zmienna=c("statistic", "pvalue"))
yes <- subset(numerics, subset=Churn.=="True.")
no <- subset(numerics, subset=Churn.=="False.")

for (i in colnames(subset(numerics, select=-Churn.))) {
  data[i] = as.numeric(churn.kstest(i))
}

data %>% kbl(caption="Wyniki testu Kolmogorova-Smirnova", format="latex") %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
@
Możemy zauważyć, że testy na największe różnice(duża wartość zmiennej \verb|statistic|) wskazują w przypadku zmiennych: CustServ.Calls, Day.Mins, Eve.Mins, 

Po przeanalizowaniu wykresów, decydujemy się na dalszą analizę następujących zmiennych: 
\begin{itemize}
  \item ilościowych:
    \begin{itemize}
    \item CustServ.Calls,
    \item Day.Mins,
    \item Eve.Mins;
    \end{itemize}
  \item jakościowych
    \begin{itemize}
    \item Int.l.Plan,
    \item VMail.Plan,
    \item Churn.
    \end{itemize}
\end{itemize}

\section{Analiza wybranych zmiennych}
Skupmy się jedynie na wybranych zmiennych:
<<nowy podzbiór danych, warning=FALSE>>=
important <- subset(df, select=c(CustServ.Calls, Day.Mins, Eve.Mins, Int.l.Plan,
                                 VMail.Plan, Churn.))
@

Wyznaczmy dla nich wskaźniki sumaryczne.

<<funkcja do wyznaczania statystyk opisowych>>=
my_summary <- function(x) {
  statistics <- c(mean(x), quantile(x, 0.25), median(x), quantile(x, 0.75), 
                  IQR(x), min(x), max(x), var(x), sd(x), kurtosis(x), skewness(x))
  names(statistics) <- c("Srednia", "Q1", "Mediana", "Q3", "IQR", "Min", "Max", 
                         "Wariancja", "Odchylenie standardowe", "Kurtoza", "Skosnosc")
  return(statistics)
}
@

<<tabela_2, echo=FALSE, eval=TRUE, results='asis'>>=
nazwy.wskaznikow <- names(my_summary(df$Day.Mins))
nazwy.zmiennych <- c("CustServ.Calls", "Day.Mins", "Eve.Mins")
CustServ.Calls.summary <- as.vector(my_summary(df$CustServ.Calls))
Day.Mins.summary <- as.vector(my_summary(df$Day.Mins))
Eve.Mins.summary <- as.vector(my_summary(df$Eve.Mins))
summary.matrix <- rbind(CustServ.Calls.summary, Day.Mins.summary, Eve.Mins.summary)
row.names(summary.matrix) <- nazwy.zmiennych
colnames(summary.matrix) <- nazwy.wskaznikow
summary.matrix %>% kbl(caption="Wskazniki sumaryczne dla wybranych zmiennych", format="latex") %>% kable_styling(latex_options=c('hold_position', 'scale_down'))
@

\section{Podsumowanie}


\end{document}